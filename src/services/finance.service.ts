/**
 * @fileoverview Servicio de Finanzas
 * @module services/finance.service
 * @description Gestiona facturas, pagos, costos de transporte,
 * tarifas y análisis financiero del TMS.
 * @author TMS-NAVITEL
 * @version 1.0.0
 */

import { apiConfig } from "@/config/api.config";
import type {
  Invoice,
  InvoiceStatus,
  InvoiceLineItem,
  Payment,
  TransportCost,
  CostType,
  ServiceRate,
  CustomerFinancialSummary,
  ProfitabilityAnalysis,
  CashFlowSummary,
  FinanceStats,
  AccountsReceivableAging,
  CreateInvoiceDTO,
  CreatePaymentDTO,
  CreateTransportCostDTO,
  InvoiceFilters,
  PaymentFilters,
  CostFilters,
} from "@/types/finance";

/* ============================================
   DATOS MOCK
   ============================================ */

const mockInvoices: Invoice[] = [
  {
    id: "inv-001",
    invoiceNumber: "INV-2026-00001",
    type: "service",
    status: "paid",
    customerId: "cust-001",
    customerName: "Alicorp S.A.A.",
    customerTaxId: "20100055237",
    customerAddress: "Av. Argentina 4793, Lima",
    customerEmail: "pagos@alicorp.com.pe",
    issueDate: "2026-01-15T00:00:00Z",
    dueDate: "2026-02-14T00:00:00Z",
    paidDate: "2026-02-10T00:00:00Z",
    currency: "PEN",
    subtotal: 15000.00,
    taxTotal: 2700.00,
    discountTotal: 0,
    total: 17700.00,
    amountPaid: 17700.00,
    amountDue: 0,
    lineItems: [
      {
        id: "li-001",
        description: "Servicio de transporte Lima - Arequipa",
        quantity: 5,
        unitPrice: 3000.00,
        unit: "viaje",
        taxRate: 18,
        taxAmount: 2700.00,
        discount: 0,
        discountType: "percentage",
        subtotal: 15000.00,
        total: 17700.00,
        orderId: "ord-001",
        orderNumber: "ORD-2026-00001",
        serviceDate: "2026-01-10T00:00:00Z",
      },
    ],
    taxes: [{ id: "tax-001", name: "IGV", code: "IGV", rate: 18, amount: 2700.00, isInclusive: false }],
    orderIds: ["ord-001"],
    createdBy: "admin",
    createdAt: "2026-01-15T00:00:00Z",
    updatedAt: "2026-02-10T00:00:00Z",
    sentAt: "2026-01-15T10:00:00Z",
  },
  {
    id: "inv-002",
    invoiceNumber: "INV-2026-00002",
    type: "service",
    status: "overdue",
    customerId: "cust-002",
    customerName: "Gloria S.A.",
    customerTaxId: "20100190797",
    issueDate: "2026-01-01T00:00:00Z",
    dueDate: "2026-01-31T00:00:00Z",
    currency: "PEN",
    subtotal: 25000.00,
    taxTotal: 4500.00,
    discountTotal: 500.00,
    total: 29000.00,
    amountPaid: 10000.00,
    amountDue: 19000.00,
    lineItems: [
      {
        id: "li-002",
        description: "Servicio de distribución Lima metropolitana",
        quantity: 10,
        unitPrice: 2500.00,
        unit: "ruta",
        taxRate: 18,
        taxAmount: 4500.00,
        discount: 500.00,
        discountType: "fixed",
        subtotal: 24500.00,
        total: 29000.00,
      },
    ],
    taxes: [{ id: "tax-002", name: "IGV", code: "IGV", rate: 18, amount: 4500.00, isInclusive: false }],
    createdBy: "admin",
    createdAt: "2026-01-01T00:00:00Z",
    updatedAt: "2026-01-01T00:00:00Z",
  },
  {
    id: "inv-003",
    invoiceNumber: "INV-2026-00003",
    type: "freight",
    status: "pending",
    customerId: "cust-003",
    customerName: "Backus S.A.",
    customerTaxId: "20100113610",
    issueDate: "2026-02-01T00:00:00Z",
    dueDate: "2026-03-03T00:00:00Z",
    currency: "PEN",
    subtotal: 50000.00,
    taxTotal: 9000.00,
    discountTotal: 0,
    total: 59000.00,
    amountPaid: 0,
    amountDue: 59000.00,
    lineItems: [
      {
        id: "li-003",
        description: "Flete internacional Chile - Lima",
        quantity: 2,
        unitPrice: 25000.00,
        unit: "contenedor",
        taxRate: 18,
        taxAmount: 9000.00,
        discount: 0,
        discountType: "percentage",
        subtotal: 50000.00,
        total: 59000.00,
      },
    ],
    taxes: [{ id: "tax-003", name: "IGV", code: "IGV", rate: 18, amount: 9000.00, isInclusive: false }],
    createdBy: "admin",
    createdAt: "2026-02-01T00:00:00Z",
    updatedAt: "2026-02-01T00:00:00Z",
  },
];

const mockPayments: Payment[] = [
  {
    id: "pay-001",
    paymentNumber: "PAY-2026-00001",
    invoiceId: "inv-001",
    invoiceNumber: "INV-2026-00001",
    customerId: "cust-001",
    customerName: "Alicorp S.A.A.",
    amount: 17700.00,
    currency: "PEN",
    method: "bank_transfer",
    status: "completed",
    paymentDate: "2026-02-10T00:00:00Z",
    referenceNumber: "TRF-202602100001",
    bankName: "BCP",
    createdAt: "2026-02-10T00:00:00Z",
    updatedAt: "2026-02-10T00:00:00Z",
  },
  {
    id: "pay-002",
    paymentNumber: "PAY-2026-00002",
    invoiceId: "inv-002",
    invoiceNumber: "INV-2026-00002",
    customerId: "cust-002",
    customerName: "Gloria S.A.",
    amount: 10000.00,
    currency: "PEN",
    method: "check",
    status: "completed",
    paymentDate: "2026-01-20T00:00:00Z",
    checkNumber: "001234567",
    bankName: "BBVA",
    createdAt: "2026-01-20T00:00:00Z",
    updatedAt: "2026-01-20T00:00:00Z",
  },
];

const mockCosts: TransportCost[] = [
  {
    id: "cost-001",
    type: "fuel",
    category: "operativo",
    description: "Combustible Diesel B5",
    amount: 5000.00,
    currency: "PEN",
    quantity: 500,
    unitCost: 10.00,
    unit: "galón",
    vehicleId: "veh-001",
    vehiclePlate: "ABC-123",
    date: "2026-02-01T00:00:00Z",
    isReimbursable: false,
    isApproved: true,
    approvedBy: "supervisor-001",
    approvedAt: "2026-02-01T12:00:00Z",
    createdAt: "2026-02-01T00:00:00Z",
    updatedAt: "2026-02-01T00:00:00Z",
  },
  {
    id: "cost-002",
    type: "toll",
    category: "operativo",
    description: "Peajes Lima - Arequipa",
    amount: 450.00,
    currency: "PEN",
    quantity: 1,
    unitCost: 450.00,
    unit: "viaje",
    vehicleId: "veh-001",
    vehiclePlate: "ABC-123",
    orderId: "ord-001",
    orderNumber: "ORD-2026-00001",
    date: "2026-01-10T00:00:00Z",
    isReimbursable: true,
    isApproved: true,
    createdAt: "2026-01-10T00:00:00Z",
    updatedAt: "2026-01-10T00:00:00Z",
  },
  {
    id: "cost-003",
    type: "maintenance",
    category: "mantenimiento",
    description: "Cambio de aceite y filtros",
    amount: 800.00,
    currency: "PEN",
    quantity: 1,
    unitCost: 800.00,
    unit: "servicio",
    vehicleId: "veh-002",
    vehiclePlate: "XYZ-789",
    date: "2026-01-25T00:00:00Z",
    isReimbursable: false,
    isApproved: true,
    createdAt: "2026-01-25T00:00:00Z",
    updatedAt: "2026-01-25T00:00:00Z",
  },
];

const mockRates: ServiceRate[] = [
  {
    id: "rate-001",
    code: "LIMA-AQP-STD",
    name: "Lima - Arequipa Standard",
    description: "Tarifa estándar para ruta Lima-Arequipa",
    category: "distance",
    baseRate: 3000.00,
    currency: "PEN",
    unit: "viaje",
    minCharge: 2500.00,
    originZone: "LIMA",
    destinationZone: "AREQUIPA",
    effectiveFrom: "2026-01-01T00:00:00Z",
    isActive: true,
    taxInclusive: false,
    taxRate: 18,
    createdAt: "2026-01-01T00:00:00Z",
    updatedAt: "2026-01-01T00:00:00Z",
  },
  {
    id: "rate-002",
    code: "DIST-LIMA-KG",
    name: "Distribución Lima por Kg",
    category: "weight",
    baseRate: 0.50,
    currency: "PEN",
    unit: "kg",
    minCharge: 100.00,
    maxCharge: 5000.00,
    originZone: "LIMA",
    destinationZone: "LIMA",
    effectiveFrom: "2026-01-01T00:00:00Z",
    isActive: true,
    taxInclusive: false,
    taxRate: 18,
    createdAt: "2026-01-01T00:00:00Z",
    updatedAt: "2026-01-01T00:00:00Z",
  },
];

/* ============================================
   SERVICIO
   ============================================ */

class FinanceService {
  private invoices: Invoice[] = [...mockInvoices];
  private payments: Payment[] = [...mockPayments];
  private costs: TransportCost[] = [...mockCosts];
  private rates: ServiceRate[] = [...mockRates];
  private useMocks: boolean;

  constructor() {
    this.useMocks = apiConfig.useMocks;
  }

  private async simulateDelay(ms: number = 200): Promise<void> {
    if (this.useMocks) {
      await new Promise(resolve => setTimeout(resolve, ms));
    }
  }

  private generateId(prefix: string): string {
    return `${prefix}-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
  }

  private generateNumber(prefix: string): string {
    const year = new Date().getFullYear();
    const seq = String(Math.floor(Math.random() * 99999)).padStart(5, "0");
    return `${prefix}-${year}-${seq}`;
  }

  // ============================================
  // FACTURAS
  // ============================================

  async getInvoices(
    filters: InvoiceFilters = {},
    page: number = 1,
    pageSize: number = 20
  ): Promise<{ data: Invoice[]; total: number; page: number; pageSize: number }> {
    await this.simulateDelay();

    if (this.useMocks) {
      let filtered = [...this.invoices];

      if (filters.search) {
        const s = filters.search.toLowerCase();
        filtered = filtered.filter(i =>
          i.invoiceNumber.toLowerCase().includes(s) ||
          i.customerName.toLowerCase().includes(s)
        );
      }
      if (filters.status) {
        const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
        filtered = filtered.filter(i => statuses.includes(i.status));
      }
      if (filters.type) {
        const types = Array.isArray(filters.type) ? filters.type : [filters.type];
        filtered = filtered.filter(i => types.includes(i.type));
      }
      if (filters.customerId) {
        filtered = filtered.filter(i => i.customerId === filters.customerId);
      }
      if (filters.startDate) {
        filtered = filtered.filter(i => new Date(i.issueDate) >= new Date(filters.startDate!));
      }
      if (filters.endDate) {
        filtered = filtered.filter(i => new Date(i.issueDate) <= new Date(filters.endDate!));
      }
      if (filters.isOverdue) {
        filtered = filtered.filter(i => i.status === "overdue");
      }
      if (filters.hasBalance) {
        filtered = filtered.filter(i => i.amountDue > 0);
      }

      filtered.sort((a, b) => new Date(b.issueDate).getTime() - new Date(a.issueDate).getTime());

      const start = (page - 1) * pageSize;
      return {
        data: filtered.slice(start, start + pageSize),
        total: filtered.length,
        page,
        pageSize,
      };
    }

    throw new Error("API not implemented");
  }

  async getInvoiceById(id: string): Promise<Invoice | null> {
    await this.simulateDelay(100);

    if (this.useMocks) {
      return this.invoices.find(i => i.id === id) || null;
    }

    throw new Error("API not implemented");
  }

  async createInvoice(data: CreateInvoiceDTO): Promise<Invoice> {
    await this.simulateDelay(300);

    if (this.useMocks) {
      const now = new Date().toISOString();
      
      // Calcular totales
      let subtotal = 0;
      let taxTotal = 0;
      let discountTotal = 0;

      const lineItems: InvoiceLineItem[] = data.lineItems.map((item, idx) => {
        const itemSubtotal = item.quantity * item.unitPrice;
        const discount = item.discountType === "percentage"
          ? itemSubtotal * (item.discount / 100)
          : item.discount;
        const taxableAmount = itemSubtotal - discount;
        const taxAmount = taxableAmount * (item.taxRate / 100);
        const total = taxableAmount + taxAmount;

        subtotal += itemSubtotal;
        taxTotal += taxAmount;
        discountTotal += discount;

        return {
          ...item,
          id: `li-${Date.now()}-${idx}`,
          taxAmount,
          subtotal: itemSubtotal,
          total,
        };
      });

      const invoice: Invoice = {
        id: this.generateId("inv"),
        invoiceNumber: this.generateNumber("INV"),
        type: data.type,
        status: "draft",
        customerId: data.customerId,
        customerName: `Cliente ${data.customerId}`,
        issueDate: data.issueDate || now,
        dueDate: data.dueDate,
        currency: data.currency || "PEN",
        subtotal,
        taxTotal,
        discountTotal,
        total: subtotal - discountTotal + taxTotal,
        amountPaid: 0,
        amountDue: subtotal - discountTotal + taxTotal,
        lineItems,
        taxes: [{ 
          id: "tax-auto", 
          name: "IGV", 
          code: "IGV", 
          rate: 18, 
          amount: taxTotal, 
          isInclusive: false 
        }],
        orderIds: data.orderIds,
        purchaseOrderNumber: data.purchaseOrderNumber,
        notes: data.notes,
        termsAndConditions: data.termsAndConditions,
        createdBy: "system",
        createdAt: now,
        updatedAt: now,
      };

      this.invoices.unshift(invoice);
      return invoice;
    }

    throw new Error("API not implemented");
  }

  async updateInvoiceStatus(id: string, status: InvoiceStatus): Promise<Invoice> {
    await this.simulateDelay(200);

    if (this.useMocks) {
      const index = this.invoices.findIndex(i => i.id === id);
      if (index === -1) throw new Error("Factura no encontrada");

      const now = new Date().toISOString();
      this.invoices[index] = {
        ...this.invoices[index],
        status,
        updatedAt: now,
        sentAt: status === "sent" ? now : this.invoices[index].sentAt,
      };

      return this.invoices[index];
    }

    throw new Error("API not implemented");
  }

  async sendInvoice(id: string): Promise<Invoice> {
    return this.updateInvoiceStatus(id, "sent");
  }

  async cancelInvoice(id: string): Promise<Invoice> {
    return this.updateInvoiceStatus(id, "cancelled");
  }

  // ============================================
  // PAGOS
  // ============================================

  async getPayments(
    filters: PaymentFilters = {},
    page: number = 1,
    pageSize: number = 20
  ): Promise<{ data: Payment[]; total: number; page: number; pageSize: number }> {
    await this.simulateDelay();

    if (this.useMocks) {
      let filtered = [...this.payments];

      if (filters.search) {
        const s = filters.search.toLowerCase();
        filtered = filtered.filter(p =>
          p.paymentNumber.toLowerCase().includes(s) ||
          p.customerName.toLowerCase().includes(s) ||
          p.invoiceNumber.toLowerCase().includes(s)
        );
      }
      if (filters.status) {
        const statuses = Array.isArray(filters.status) ? filters.status : [filters.status];
        filtered = filtered.filter(p => statuses.includes(p.status));
      }
      if (filters.method) {
        const methods = Array.isArray(filters.method) ? filters.method : [filters.method];
        filtered = filtered.filter(p => methods.includes(p.method));
      }
      if (filters.invoiceId) {
        filtered = filtered.filter(p => p.invoiceId === filters.invoiceId);
      }
      if (filters.customerId) {
        filtered = filtered.filter(p => p.customerId === filters.customerId);
      }
      if (filters.startDate) {
        filtered = filtered.filter(p => new Date(p.paymentDate) >= new Date(filters.startDate!));
      }
      if (filters.endDate) {
        filtered = filtered.filter(p => new Date(p.paymentDate) <= new Date(filters.endDate!));
      }

      filtered.sort((a, b) => 
        new Date(b.paymentDate).getTime() - new Date(a.paymentDate).getTime()
      );

      const start = (page - 1) * pageSize;
      return {
        data: filtered.slice(start, start + pageSize),
        total: filtered.length,
        page,
        pageSize,
      };
    }

    throw new Error("API not implemented");
  }

  async recordPayment(data: CreatePaymentDTO): Promise<Payment> {
    await this.simulateDelay(300);

    if (this.useMocks) {
      // Encontrar factura
      const invoice = this.invoices.find(i => i.id === data.invoiceId);
      if (!invoice) throw new Error("Factura no encontrada");

      const now = new Date().toISOString();

      const payment: Payment = {
        id: this.generateId("pay"),
        paymentNumber: this.generateNumber("PAY"),
        invoiceId: data.invoiceId,
        invoiceNumber: invoice.invoiceNumber,
        customerId: invoice.customerId,
        customerName: invoice.customerName,
        amount: data.amount,
        currency: invoice.currency,
        method: data.method,
        status: "completed",
        paymentDate: data.paymentDate,
        referenceNumber: data.referenceNumber,
        bankName: data.bankName,
        accountNumber: data.accountNumber,
        checkNumber: data.checkNumber,
        notes: data.notes,
        createdAt: now,
        updatedAt: now,
      };

      this.payments.unshift(payment);

      // Actualizar factura
      const invIndex = this.invoices.findIndex(i => i.id === data.invoiceId);
      if (invIndex !== -1) {
        const inv = this.invoices[invIndex];
        const newAmountPaid = inv.amountPaid + data.amount;
        const newAmountDue = inv.total - newAmountPaid;

        let newStatus: InvoiceStatus = inv.status;
        if (newAmountDue <= 0) {
          newStatus = "paid";
        } else if (newAmountPaid > 0) {
          newStatus = "partial";
        }

        this.invoices[invIndex] = {
          ...inv,
          amountPaid: newAmountPaid,
          amountDue: Math.max(0, newAmountDue),
          status: newStatus,
          paidDate: newStatus === "paid" ? now : inv.paidDate,
          updatedAt: now,
        };
      }

      return payment;
    }

    throw new Error("API not implemented");
  }

  async getPaymentsByInvoice(invoiceId: string): Promise<Payment[]> {
    await this.simulateDelay(100);

    if (this.useMocks) {
      return this.payments.filter(p => p.invoiceId === invoiceId);
    }

    throw new Error("API not implemented");
  }

  // ============================================
  // COSTOS
  // ============================================

  async getCosts(
    filters: CostFilters = {},
    page: number = 1,
    pageSize: number = 20
  ): Promise<{ data: TransportCost[]; total: number; page: number; pageSize: number }> {
    await this.simulateDelay();

    if (this.useMocks) {
      let filtered = [...this.costs];

      if (filters.search) {
        const s = filters.search.toLowerCase();
        filtered = filtered.filter(c =>
          c.description.toLowerCase().includes(s) ||
          c.vehiclePlate?.toLowerCase().includes(s)
        );
      }
      if (filters.type) {
        const types = Array.isArray(filters.type) ? filters.type : [filters.type];
        filtered = filtered.filter(c => types.includes(c.type));
      }
      if (filters.vehicleId) {
        filtered = filtered.filter(c => c.vehicleId === filters.vehicleId);
      }
      if (filters.orderId) {
        filtered = filtered.filter(c => c.orderId === filters.orderId);
      }
      if (filters.startDate) {
        filtered = filtered.filter(c => new Date(c.date) >= new Date(filters.startDate!));
      }
      if (filters.endDate) {
        filtered = filtered.filter(c => new Date(c.date) <= new Date(filters.endDate!));
      }
      if (filters.isApproved !== undefined) {
        filtered = filtered.filter(c => c.isApproved === filters.isApproved);
      }

      filtered.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());

      const start = (page - 1) * pageSize;
      return {
        data: filtered.slice(start, start + pageSize),
        total: filtered.length,
        page,
        pageSize,
      };
    }

    throw new Error("API not implemented");
  }

  async recordCost(data: CreateTransportCostDTO): Promise<TransportCost> {
    await this.simulateDelay(200);

    if (this.useMocks) {
      const now = new Date().toISOString();

      const cost: TransportCost = {
        id: this.generateId("cost"),
        type: data.type,
        category: data.category || "general",
        description: data.description,
        amount: data.amount,
        currency: data.currency || "PEN",
        quantity: data.quantity || 1,
        unitCost: data.amount / (data.quantity || 1),
        unit: data.unit || "unidad",
        orderId: data.orderId,
        vehicleId: data.vehicleId,
        driverId: data.driverId,
        routeId: data.routeId,
        date: data.date,
        isReimbursable: data.isReimbursable || false,
        isApproved: false,
        receiptNumber: data.receiptNumber,
        notes: data.notes,
        createdAt: now,
        updatedAt: now,
      };

      this.costs.unshift(cost);
      return cost;
    }

    throw new Error("API not implemented");
  }

  async approveCost(id: string, approvedBy: string): Promise<TransportCost> {
    await this.simulateDelay(200);

    if (this.useMocks) {
      const index = this.costs.findIndex(c => c.id === id);
      if (index === -1) throw new Error("Costo no encontrado");

      const now = new Date().toISOString();
      this.costs[index] = {
        ...this.costs[index],
        isApproved: true,
        approvedBy,
        approvedAt: now,
        updatedAt: now,
      };

      return this.costs[index];
    }

    throw new Error("API not implemented");
  }

  async getCostsByOrder(orderId: string): Promise<TransportCost[]> {
    await this.simulateDelay(100);

    if (this.useMocks) {
      return this.costs.filter(c => c.orderId === orderId);
    }

    throw new Error("API not implemented");
  }

  async getCostsByVehicle(vehicleId: string): Promise<TransportCost[]> {
    await this.simulateDelay(100);

    if (this.useMocks) {
      return this.costs.filter(c => c.vehicleId === vehicleId);
    }

    throw new Error("API not implemented");
  }

  // ============================================
  // TARIFAS
  // ============================================

  async getRates(
    filters: { category?: string; originZone?: string; destinationZone?: string; isActive?: boolean } = {}
  ): Promise<ServiceRate[]> {
    await this.simulateDelay();

    if (this.useMocks) {
      let filtered = [...this.rates];

      if (filters.category) {
        filtered = filtered.filter(r => r.category === filters.category);
      }
      if (filters.originZone) {
        filtered = filtered.filter(r => r.originZone === filters.originZone);
      }
      if (filters.destinationZone) {
        filtered = filtered.filter(r => r.destinationZone === filters.destinationZone);
      }
      if (filters.isActive !== undefined) {
        filtered = filtered.filter(r => r.isActive === filters.isActive);
      }

      return filtered;
    }

    throw new Error("API not implemented");
  }

  async getRateById(id: string): Promise<ServiceRate | null> {
    await this.simulateDelay(100);

    if (this.useMocks) {
      return this.rates.find(r => r.id === id) || null;
    }

    throw new Error("API not implemented");
  }

  async calculateRate(
    originZone: string,
    destinationZone: string,
    weight?: number,
    volume?: number
  ): Promise<{ rate: ServiceRate | null; amount: number }> {
    await this.simulateDelay(150);

    if (this.useMocks) {
      const rate = this.rates.find(r =>
        r.isActive &&
        r.originZone === originZone &&
        r.destinationZone === destinationZone
      );

      if (!rate) return { rate: null, amount: 0 };

      let amount = rate.baseRate;

      if (rate.category === "weight" && weight) {
        amount = rate.baseRate * weight;
      } else if (rate.category === "volume" && volume) {
        amount = rate.baseRate * volume;
      }

      // Aplicar min/max
      if (rate.minCharge) amount = Math.max(amount, rate.minCharge);
      if (rate.maxCharge) amount = Math.min(amount, rate.maxCharge);

      return { rate, amount };
    }

    throw new Error("API not implemented");
  }

  // ============================================
  // ANÁLISIS FINANCIERO
  // ============================================

  async getFinanceStats(
    startDate?: string,
    endDate?: string
  ): Promise<FinanceStats> {
    await this.simulateDelay(400);

    if (this.useMocks) {
      let invoices = [...this.invoices];
      let costs = [...this.costs];

      if (startDate) {
        invoices = invoices.filter(i => new Date(i.issueDate) >= new Date(startDate));
        costs = costs.filter(c => new Date(c.date) >= new Date(startDate));
      }
      if (endDate) {
        invoices = invoices.filter(i => new Date(i.issueDate) <= new Date(endDate));
        costs = costs.filter(c => new Date(c.date) <= new Date(endDate));
      }

      const totalInvoiced = invoices.reduce((sum, i) => sum + i.total, 0);
      const totalPaid = invoices.reduce((sum, i) => sum + i.amountPaid, 0);
      const totalPending = invoices.filter(i => i.status === "pending").reduce((sum, i) => sum + i.amountDue, 0);
      const totalOverdue = invoices.filter(i => i.status === "overdue").reduce((sum, i) => sum + i.amountDue, 0);

      const totalCosts = costs.reduce((sum, c) => sum + c.amount, 0);

      // Costos por tipo
      const costsByTypeMap = new Map<string, number>();
      for (const cost of costs) {
        const current = costsByTypeMap.get(cost.type) || 0;
        costsByTypeMap.set(cost.type, current + cost.amount);
      }
      const costsByType = Array.from(costsByTypeMap.entries()).map(([type, amount]) => ({
        type: type as CostType,
        amount,
      }));

      return {
        totalInvoiced,
        totalPaid,
        totalPending,
        totalOverdue,
        invoiceCount: invoices.length,
        paidCount: invoices.filter(i => i.status === "paid").length,
        pendingCount: invoices.filter(i => i.status === "pending" || i.status === "sent").length,
        overdueCount: invoices.filter(i => i.status === "overdue").length,
        totalCosts,
        costsByType,
        grossRevenue: totalInvoiced,
        netRevenue: totalPaid - totalCosts,
        profitMargin: totalPaid > 0 ? ((totalPaid - totalCosts) / totalPaid) * 100 : 0,
        revenueGrowth: 12.5, // Mock
        costGrowth: 5.2, // Mock
      };
    }

    throw new Error("API not implemented");
  }

  async getCustomerFinancialSummary(customerId: string): Promise<CustomerFinancialSummary> {
    await this.simulateDelay(300);

    if (this.useMocks) {
      const customerInvoices = this.invoices.filter(i => i.customerId === customerId);

      const totalInvoiced = customerInvoices.reduce((sum, i) => sum + i.total, 0);
      const totalPaid = customerInvoices.reduce((sum, i) => sum + i.amountPaid, 0);
      const totalDue = customerInvoices.reduce((sum, i) => sum + i.amountDue, 0);
      const overdueAmount = customerInvoices
        .filter(i => i.status === "overdue")
        .reduce((sum, i) => sum + i.amountDue, 0);

      const paidInvoices = customerInvoices.filter(i => i.status === "paid" && i.paidDate);
      const avgPaymentDays = paidInvoices.length > 0
        ? Math.round(
            paidInvoices.reduce((sum, i) => {
              const issue = new Date(i.issueDate).getTime();
              const paid = new Date(i.paidDate!).getTime();
              return sum + (paid - issue) / (1000 * 60 * 60 * 24);
            }, 0) / paidInvoices.length
          )
        : 0;

      return {
        customerId,
        customerName: customerInvoices[0]?.customerName || `Cliente ${customerId}`,
        totalInvoiced,
        totalPaid,
        totalDue,
        overdueAmount,
        invoiceCount: customerInvoices.length,
        paidInvoiceCount: customerInvoices.filter(i => i.status === "paid").length,
        pendingInvoiceCount: customerInvoices.filter(i => 
          i.status === "pending" || i.status === "sent"
        ).length,
        overdueInvoiceCount: customerInvoices.filter(i => i.status === "overdue").length,
        avgPaymentDays,
        avgInvoiceAmount: customerInvoices.length > 0 
          ? totalInvoiced / customerInvoices.length 
          : 0,
        periodStart: "2026-01-01T00:00:00Z",
        periodEnd: new Date().toISOString(),
      };
    }

    throw new Error("API not implemented");
  }

  async getAccountsReceivableAging(): Promise<AccountsReceivableAging> {
    await this.simulateDelay(300);

    if (this.useMocks) {
      const now = new Date();
      const pendingInvoices = this.invoices.filter(i => 
        i.amountDue > 0 && i.status !== "cancelled"
      );

      let current = 0;
      let days1to30 = 0;
      let days31to60 = 0;
      let days61to90 = 0;
      let over90Days = 0;

      for (const inv of pendingInvoices) {
        const due = new Date(inv.dueDate);
        const daysOverdue = Math.floor((now.getTime() - due.getTime()) / (1000 * 60 * 60 * 24));

        if (daysOverdue <= 0) {
          current += inv.amountDue;
        } else if (daysOverdue <= 30) {
          days1to30 += inv.amountDue;
        } else if (daysOverdue <= 60) {
          days31to60 += inv.amountDue;
        } else if (daysOverdue <= 90) {
          days61to90 += inv.amountDue;
        } else {
          over90Days += inv.amountDue;
        }
      }

      return {
        current,
        days1to30,
        days31to60,
        days61to90,
        over90Days,
        total: current + days1to30 + days31to60 + days61to90 + over90Days,
      };
    }

    throw new Error("API not implemented");
  }

  async getProfitabilityAnalysis(
    startDate: string,
    endDate: string
  ): Promise<ProfitabilityAnalysis> {
    await this.simulateDelay(500);

    if (this.useMocks) {
      const invoices = this.invoices.filter(i =>
        new Date(i.issueDate) >= new Date(startDate) &&
        new Date(i.issueDate) <= new Date(endDate)
      );

      const costs = this.costs.filter(c =>
        new Date(c.date) >= new Date(startDate) &&
        new Date(c.date) <= new Date(endDate)
      );

      const totalRevenue = invoices.reduce((sum, i) => sum + i.total, 0);
      const totalCosts = costs.reduce((sum, c) => sum + c.amount, 0);

      const fuelCosts = costs.filter(c => c.type === "fuel").reduce((s, c) => s + c.amount, 0);
      const laborCosts = costs.filter(c => c.type === "labor").reduce((s, c) => s + c.amount, 0);
      const maintenanceCosts = costs.filter(c => c.type === "maintenance").reduce((s, c) => s + c.amount, 0);
      const tollCosts = costs.filter(c => c.type === "toll").reduce((s, c) => s + c.amount, 0);

      const grossProfit = totalRevenue - totalCosts;
      const grossMarginPercent = totalRevenue > 0 ? (grossProfit / totalRevenue) * 100 : 0;

      return {
        periodStart: startDate,
        periodEnd: endDate,
        totalRevenue,
        serviceRevenue: totalRevenue * 0.85,
        accessorialRevenue: totalRevenue * 0.10,
        otherRevenue: totalRevenue * 0.05,
        totalCosts,
        fuelCosts,
        laborCosts,
        maintenanceCosts,
        insuranceCosts: 0,
        tollCosts,
        depreciationCosts: 0,
        administrativeCosts: 0,
        otherCosts: totalCosts - fuelCosts - laborCosts - maintenanceCosts - tollCosts,
        grossProfit,
        grossMarginPercent,
        operatingProfit: grossProfit * 0.85,
        operatingMarginPercent: grossMarginPercent * 0.85,
        netProfit: grossProfit * 0.75,
        netMarginPercent: grossMarginPercent * 0.75,
      };
    }

    throw new Error("API not implemented");
  }

  async getCashFlowSummary(
    startDate: string,
    endDate: string
  ): Promise<CashFlowSummary> {
    await this.simulateDelay(400);

    if (this.useMocks) {
      const payments = this.payments.filter(p =>
        p.status === "completed" &&
        new Date(p.paymentDate) >= new Date(startDate) &&
        new Date(p.paymentDate) <= new Date(endDate)
      );

      const costs = this.costs.filter(c =>
        new Date(c.date) >= new Date(startDate) &&
        new Date(c.date) <= new Date(endDate)
      );

      const customerPayments = payments.reduce((sum, p) => sum + p.amount, 0);
      const totalOutflows = costs.reduce((sum, c) => sum + c.amount, 0);
      const fuelExpenses = costs.filter(c => c.type === "fuel").reduce((s, c) => s + c.amount, 0);

      return {
        periodStart: startDate,
        periodEnd: endDate,
        openingBalance: 100000, // Mock
        closingBalance: 100000 + customerPayments - totalOutflows,
        totalInflows: customerPayments,
        customerPayments,
        otherInflows: 0,
        totalOutflows,
        supplierPayments: totalOutflows * 0.3,
        fuelExpenses,
        salaryPayments: totalOutflows * 0.4,
        otherOutflows: totalOutflows * 0.1,
        netCashFlow: customerPayments - totalOutflows,
      };
    }

    throw new Error("API not implemented");
  }
}

export const financeService = new FinanceService();

export default financeService;
